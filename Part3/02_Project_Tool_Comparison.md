# 🛠️ 팀미팅 정리 - npm vs pnpm, Tailwind vs Panda CSS vs Vanilla Extract

## ✅ 질문 1: npm vs pnpm

### 📌 기본 개념

- `npm`: Node.js의 공식 패키지 매니저. 전통적인 방식으로 패키지를 `node_modules`에 복사.
- `pnpm`: **성능 최적화된 패키지 매니저**. 동일한 패키지를 전역 저장소에 한 번만 설치하고, 프로젝트에는 하드 링크로 연결함.

### 🔍 비교 요약

| 항목                    | `npm`                                                                | `pnpm`                                                                         |
| ----------------------- | -------------------------------------------------------------------- | ------------------------------------------------------------------------------ |
| 디스크 사용량           | 많음 (중복 저장)                                                     | 적음 (하드 링크)                                                               |
| 설치 속도               | 느림                                                                 | 빠름 (캐시/병렬 처리 최적화)                                                   |
| 의존성 관리             | 느슨함                                                               | 엄격함 (정확한 명시 필요)                                                      |
| 워크스페이스 (Monorepo) | 제한적 (v7부터 기본 지원)<br>기능은 있으나 설정이 복잡하고 성능 제한 | ✅ 기본 지원 + 성능 최적화<br>대규모 프로젝트와 Monorepo에 최적화됨            |
| 캐시 활용               | 일반적                                                               | 고성능 저장소 활용                                                             |
| 커뮤니티 및 안정성      | 오래되고 안정적                                                      | 빠르게 성장 중                                                                 |
| 특징 요약               | - Node.js 기본 도구<br>- 가장 널리 사용됨<br>- 추가 설정 필요 없음   | - 빠른 속도 및 디스크 절약<br>- 유령 의존성 문제 없음<br>- 모노레포에 최적화됨 |
| 단점 요약               | - 디스크 낭비 심함<br>- 유령 의존성 발생 가능성 있음                 | - 일부 라이브러리와의 호환성 이슈<br>- 특정 플러그인과 통합 어려움 가능        |

### 📦 모노레포란?

> **Monorepo (모노레포)**는 여러 패키지를 하나의 저장소(Repository)에서 관리하는 방식입니다.

### 📁 전통적 멀티레포 vs 모노레포

| 방식     | 설명                                 | 예시                                                 |
| -------- | ------------------------------------ | ---------------------------------------------------- |
| 멀티레포 | 패키지마다 별도 저장소 관리          | frontend, backend 각기 다른 Git 저장소               |
| 모노레포 | 모든 패키지를 하나의 저장소에서 관리 | frontend, backend, shared-lib를 하나의 repo에서 관리 |

### ✅ 모노레포의 장점

- **공통 설정 공유**: ESLint, Prettier, tsconfig 등을 루트에서 공유 가능
- **버전 및 의존성 통합 관리**: 모든 패키지의 버전을 일괄적으로 업그레이드 가능
- **CI/CD 단순화**: 테스트/빌드 프로세스 통합으로 효율적
- **코드 재사용 용이**: 내부 패키지 간 쉽게 import 가능

### ❗그렇다면 소규모 프로젝트에서 pnpm을 선택할 이유는?

모노레포 이점이 적더라도 `pnpm`은 다음과 같은 이유로 유용합니다:

- **디스크 공간 절약**: 여러 프로젝트를 동시에 운영할 경우 유용
- **설치 속도 향상**: 캐시 기반 설치로 npm 대비 체감 속도 빠름
- **일관된 의존성 트리**: 유령 의존성 방지로 디버깅 시간 절약
- **npm과 거의 동일한 명령어 체계**: 러닝커브 없음
- **기본적인 workspace도 간단히 관리 가능**: 설정이 간단해도 이점 있음

> 즉, 규모와 상관없이 `pnpm`은 **빠른 설치**, **디스크 효율성**, **안정적인 의존성 관리** 덕분에 유용한 선택지입니다.

> 🔍 `pnpm`은 모노레포에 **최적화된 구조와 성능**을 제공하며, `npm` 대비 유지보수 및 속도 면에서 이점을 가짐. 그러나 단일 프로젝트에서도 성능과 안정성 면에서 충분한 가치를 제공합니다.

---

## ✅ 질문 2: Tailwind vs Vanilla Extract vs Panda CSS

### 📌 스타일링 라이브러리 비교

| 항목          | Tailwind CSS          | Vanilla Extract          | Panda CSS                        |
| ------------- | --------------------- | ------------------------ | -------------------------------- |
| 스타일 방식   | 유틸리티-first 클래스 | TypeScript 기반 CSS 추출 | Design Token 기반 CSS-in-JS      |
| 타입 지원     | ❌ 없음               | ✅ 완벽                  | ✅ 기본 제공                     |
| 디자인 시스템 | ❌ 직접 구현          | ❌ 직접 구현             | ✅ Token 기반 자동 적용          |
| 런타임 부담   | 거의 없음 (JIT)       | 없음 (정적 추출)         | 없음 (정적 추출)                 |
| 러닝 커브     | 낮음                  | 높음 (TS 필요)           | 중간 (Tailwind 경험 있으면 쉬움) |
| 재사용성      | 클래스 재사용         | 변수/함수 재사용         | token 조합 재사용                |

---

### 📘 추가 설명 및 장단점

#### ✅ Tailwind CSS

- **장점**:
  - 빠른 개발, 일관된 디자인 시스템 유지에 유리
  - 클래스 작명 불필요 → 빠른 시안 제작에 적합
  - 성능 최적화(JIT 방식) 및 반응형 스타일링 편리
- **단점**:
  - 러닝 커브 존재 (처음엔 클래스 외우기 힘듬)
  - JSX에 클래스가 몰려 가독성 저하 가능
  - 조건부 스타일링 복잡 (→ `clsx` 또는 `classNames` 사용 권장)
- **적합한 상황**:
  - 빠른 UI 프로토타이핑
  - 일관된 디자인 시스템 구성
  - 복잡하지 않은 스타일 요구 시 최적

#### ✅ Vanilla Extract

- **장점**:
  - TypeScript 기반 → **완벽한 타입 안전성** 제공
  - 런타임 오버헤드 없음 (정적 CSS 생성)
  - 변수화/재사용에 강력 → 테마 단위 스타일링 용이
- **단점**:
  - 러닝 커브 존재 (TS 필요 + 빌드 파이프라인 이해 필요)
  - Tailwind처럼 즉시 클래스 적용은 불가 → 추상화 필요
- **적합한 상황**:
  - 타입 안정성을 중요하게 여기는 프로젝트
  - 디자인 시스템을 명확하게 구성할 필요가 있는 경우

#### ✅ Panda CSS

- **장점**:
  - 런타임 오버헤드 없음 + 정적 추출 방식
  - 조건부 스타일링 간편 (`css({ bg: isDark ? 'gray.800' : 'white' })`)
  - 타입 지원 및 디자인 토큰 기반 구조 → 협업에 유리
- **단점**:
  - 스타일 변경 시 빌드 명령 필요
  - 상대적으로 생태계 작고 예외 상황 발생 가능
- **적합한 상황**:
  - 디자인 시스템이 중요하고, 타입 안정성을 중시하는 팀

---

### 🧪 코드 예시

#### ✅ Tailwind

```jsx
<div className="w-full md:w-1/2 lg:w-1/3 text-sm md:text-base lg:text-lg">반응형 박스 (Tailwind)</div>
```

#### ✅ Vanilla Extract

```ts
// styles.css.ts
export const box = style({
  backgroundColor: 'white',
  padding: '16px',
  selectors: {
    '@media': {
      '(min-width: 768px)': { width: '50%' },
      '(min-width: 1024px)': { width: '33.33%' },
    },
  },
});
```

```tsx
<div className={box}>반응형 박스 (Vanilla Extract)</div>
```

#### ✅ Panda CSS

```tsx
<div
  className={css({
    width: ['100%', '50%', '33.3333%'],
    fontSize: ['sm', 'md', 'lg'],
  })}>
  반응형 박스 (Panda CSS)
</div>
```

---

### ✅ 결론 정리

| 상황                              | 추천 도구           |
| --------------------------------- | ------------------- |
| 빠른 개발, 간편한 스타일링        | **Tailwind CSS**    |
| 타입 안정성, 정적 추출 + 재사용성 | **Vanilla Extract** |
| 디자인 시스템 내장, 타입 지원까지 | **Panda CSS**       |

---

### 💬 부연 설명

- **Vanilla Extract**는 정적 CSS 추출이 목적이라 빌드 시점에 성능 이점을 줌
- **Panda CSS**는 Design Token을 활용한 설계 구조를 강제하여 협업 시 유리
- 팀 규모가 크거나 디자인 시스템을 도입하는 경우 **Panda CSS** 또는 **Vanilla Extract**가 유지보수에 용이
