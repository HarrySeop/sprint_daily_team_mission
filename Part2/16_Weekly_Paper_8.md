# 🗓️ 위클리 페이퍼 (Week 8)

## 🔄 리액트 생명주기 (React Life Cycle)란?

React 컴포넌트는 **생성 → 업데이트 → 소멸**의 과정을 거칩니다. 이 과정을 **생명주기**라고 하며, 각 시점마다 특정 메서드나 훅이 실행됩니다.

### ✅ 함수형 컴포넌트 + Hook 기준 생명주기 흐름

| 단계              | 설명                            | 관련 훅                                              |
| ----------------- | ------------------------------- | ---------------------------------------------------- |
| 마운트(Mount)     | 컴포넌트가 처음 화면에 렌더링됨 | `useEffect(() => {...}, [])`                         |
| 업데이트(Update)  | 상태/props 변경으로 리렌더링됨  | `useEffect(() => {...}, [dep])`                      |
| 언마운트(Unmount) | 컴포넌트가 제거됨               | `useEffect(() => {...}, [])` 내 `return () => {...}` |

### ✅ 주요 훅 예시 코드

```jsx
import { useEffect, useState } from 'react';

function Example() {
  const [count, setCount] = useState(0);

  // Mount & Unmount
  useEffect(() => {
    console.log('마운트');
    return () => {
      console.log('언마운트');
    };
  }, []);

  // Update
  useEffect(() => {
    console.log('카운트 변경:', count);
  }, [count]);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>증가</button>
    </div>
  );
}
```

---

## 🌐 웹 페이지 렌더링 방식 비교 (CSR / SSR / SSG)

React 기반 프로젝트는 주로 3가지 방식으로 렌더링할 수 있습니다:

### 1️⃣ CSR (Client-Side Rendering)

| 항목    | 설명                                                            |
| ------- | --------------------------------------------------------------- |
| 정의    | 클라이언트에서 JS가 실행되어 화면을 그리는 방식 (브라우저 기반) |
| 흐름    | HTML + JS 번들 전송 → 브라우저가 JS 파싱 후 컴포넌트 렌더링     |
| 장점    | 페이지 전환 빠름, 상호작용에 강함 (SPA 구조에 적합)             |
| 단점    | 초기 화면이 늦게 뜰 수 있음 (빈 화면 → 로딩), SEO 불리          |
| 사용 예 | 내부 시스템, 관리자 페이지, SPA 웹앱 등                         |

### 2️⃣ SSR (Server-Side Rendering)

| 항목    | 설명                                              |
| ------- | ------------------------------------------------- |
| 정의    | 서버에서 HTML을 완성해 클라이언트에 전달하는 방식 |
| 흐름    | 요청 시 서버에서 React 렌더 → 완성된 HTML 반환    |
| 장점    | 초기 로딩 속도 빠름, SEO에 유리 (크롤링 가능)     |
| 단점    | 매 요청마다 서버 부하, 동적 처리 복잡도 증가      |
| 사용 예 | 커머스, 블로그, 콘텐츠 기반 서비스 등             |

### 3️⃣ SSG (Static Site Generation)

| 항목    | 설명                                                     |
| ------- | -------------------------------------------------------- |
| 정의    | 빌드 타임에 미리 HTML 파일을 생성하는 방식 (정적 사이트) |
| 흐름    | 배포 전 모든 HTML을 생성 → CDN 등에 저장하여 응답        |
| 장점    | 응답속도 빠름, 트래픽에 강함, 유지보수 편함, SEO 좋음    |
| 단점    | 데이터 변경 시 재빌드 필요, 실시간 반영 어려움           |
| 사용 예 | 마케팅 페이지, 블로그, 문서 사이트 등                    |

---

## 🔁 혼합 방식 (하이브리드 렌더링)

Next.js 등의 프레임워크에서는 **CSR + SSR + SSG를 혼합하여 사용**할 수 있습니다.

예를 들어:

- 메인 페이지: `SSG` (정적 렌더링)
- 상품 상세 페이지: `SSR` (서버 요청 시 동적 생성)
- 내부 관리 페이지: `CSR` (JS 기반 동작)

📌 **React 자체로는 CSR이 기본**이며, SSR/SSG는 Next.js 등의 프레임워크가 지원합니다.

---

## 🤝 백엔드와 협업 시 렌더링 방식 선택 기준

| 조건                       | 추천 방식                            |
| -------------------------- | ------------------------------------ |
| 로그인 기반 내부 시스템    | CSR (로딩 이후 모든 데이터 fetch)    |
| SEO가 중요한 서비스        | SSR, SSG (검색 엔진에 노출되기 위함) |
| API 응답이 빠르고 정적이면 | SSG (빌드 시점 생성)                 |
| 동적 요청/사용자별 응답    | SSR (요청마다 서버 렌더링 필요)      |

> ✅ **CSR**: React 단독, REST/GraphQL API 요청 중심
> ✅ **SSR/SSG**: 백엔드 API와의 데이터 협의 필요 (빌드 타임/요청 타임 분리)

---

## 📌 렌더링 방식 요약 비교

| 항목           | CSR       | SSR  | SSG       |
| -------------- | --------- | ---- | --------- |
| 초기 로딩 속도 | 느림      | 빠름 | 가장 빠름 |
| SEO            | 불리      | 유리 | 유리      |
| 실시간성       | 매우 좋음 | 좋음 | 낮음      |
| 서버 부하      | 없음      | 높음 | 없음      |
| 데이터 최신성  | 실시간    | 최신 | 빌드 기준 |

---
